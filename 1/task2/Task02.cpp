//Хромой король.На квадратной доске расставлены монеты, достоинством от 1 до
//100. Хромой король, находящийся в правом нижнем углу, мечтает попасть в левый верхний.
//При этом он может передвигаться только в клетку слева или сверху и хочет, чтобы сумма всех
//монет, оказавшихся у него на пути, была бы максимальной.Определить эту сумму и путь, каким
//образом должен двигаться король, чтобы ее собрать.Ввод и вывод организовать при помощи
//текстовых файлов.Формат входных данных : в первой строке входного файла записано число N
//- размер доски(1 < N < 80).Далее следует N строк, каждая из которых содержит N целых чисел,
//представляющих доску.В первую строку выходного файл нужно вывести единственное число :
//максимальную сумму, а во второй строке вывести путь в виде строки символов, обозначив символом L 
//движение влево, а символом U - движение вверх.

#include <iostream>
#include <fstream>
#include <vector>

using namespace std;

int main() {
    ifstream input("a.txt");
    ofstream output("b.txt");

    int N;
    input >> N;

    // Используем вектор векторов для представления доски
    vector<vector<int>> docka(N, vector<int>(N));

    // Чтение доски из файла
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            input >> docka[i][j];
        }
    }

    // Вектор для хранения максимальных сумм
    vector< vector<int>> dp(N, vector<int>(N, 0));

    // Начальная позиция (правый нижний угол)
    dp[N - 1][N - 1] = docka[N - 1][N - 1];

    // Заполнение таблицы максимальных сумм
    for (int i = N - 1; i >= 0; --i) {
        for (int j = N - 1; j >= 0; --j) {
            if (i < N - 1) {
                dp[i][j] = max(dp[i][j], dp[i + 1][j] + docka[i][j]);
            }
            if (j < N - 1) {
                dp[i][j] = max(dp[i][j], dp[i][j + 1] + docka[i][j]);
            }
        }
    }

    // Максимальная сумма монет
    int maxSum = dp[0][0];
    output << maxSum << endl;

    // Восстановление пути
    vector<char> path;
    int x = 0, y = 0;

    while (x < N - 1 || y < N - 1) {
        if (x == N - 1) { // можем двигаться только вверх
            path.push_back('L');
            y++;
        }
        else if (y == N - 1) { // можем двигаться только влево
            path.push_back('U');
            x++;
        }
        else if (dp[x + 1][y] > dp[x][y + 1]) { // двигаться вверх
            path.push_back('L');
            y++;
        }
        else { 
            path.push_back('U'); // двигаться влево
            x++;
        }
    }

    // Вывод пути
    for (char move : path) {
        output << move;
    }
    output << endl;

    input.close();
    output.close();

    return 0;
}
