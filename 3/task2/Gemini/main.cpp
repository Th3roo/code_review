/* Задание CalcTree3: Построить дерево выражения из RPN в файле,
   заменить узлы умножения их вычисленными значениями, вывести указатель на корень. */
#include <iostream>
#include <string>
#include <fstream>  // Required for file existence check example (optional)
#include <cstdlib>  // For EXIT_SUCCESS, EXIT_FAILURE
#include "ExpressionTree.h" // Include our header

using namespace std;

// --- Optional Helper: Check if file exists ---
/**
 * @brief Проверяет существование файла.
 * @param filename Имя файла для проверки.
 * @return true, если файл существует и доступен для чтения, иначе false.
 */
bool fileExists(const string& filename) {
	ifstream f(filename.c_str());
	return f.good();
}

/**
 * @brief Главная функция программы CalcTree3.
 *        Задает имя файла, строит дерево, трансформирует его,
 *        выводит адрес корня и очищает память.
 * @param argc Количество аргументов командной строки (не используется).
 * @param argv Вектор аргументов командной строки (не используется).
 * @return EXIT_SUCCESS при успехе, EXIT_FAILURE при ошибке.
 */
int main(int argc, char* argv[]) {
	// Имя файла с RPN выражением (согласно заданию "filename")
	const string inputFilename = "input.txt"; // Используем фиксированное имя файла

	// --- Предварительная проверка существования файла (не обязательно, но полезно) ---
	if (!fileExists(inputFilename)) {
		cerr << "Ошибка: Файл '" << inputFilename << "' не найден или недоступен." << endl;
		// Создадим пример файла для удобства тестирования, если его нет
        cerr << "Создание примерного файла 'input.txt' с выражением '5 3 + 8 * 2 /'..." << endl;
        ofstream exampleFile(inputFilename);
        if(exampleFile.is_open()){
            exampleFile << "5 3 + 8 * 2 /" << endl; // Пример: (5+3)*8 / 2 = 32
            exampleFile.close();
            cerr << "Файл 'input.txt' создан. Пожалуйста, запустите программу снова." << endl;
        } else {
            cerr << "Не удалось создать примерный файл." << endl;
        }
		return EXIT_FAILURE;
	}

	// --- Построение дерева ---
	Node* root = buildTreeFromFile(inputFilename);

	if (root == nullptr) {
		// Сообщение об ошибке уже выведено функцией buildTreeFromFile
		cerr << "Не удалось построить дерево выражений." << endl;
		return EXIT_FAILURE;
	}

	// --- Трансформация дерева ---
	// Заменяем узлы умножения (*) их вычисленными значениями
	Node* transformedRoot = transformTree(root);

	if (transformedRoot == nullptr) {
		// Ошибка произошла во время трансформации (например, деление на ноль в поддереве)
		// Сообщение об ошибке уже выведено функцией transformTree
		cerr << "Не удалось трансформировать дерево выражений." << endl;
		// Важно: Исходное дерево (или его остатки) всё ещё может быть в 'root'.
		// Но так как transformTree при ошибке должен был вызвать delete на узле,
		// где произошла ошибка, пытаться удалить 'root' здесь может быть опасно
		// (двойное удаление). Безопаснее просто выйти. В идеале, transformTree
		// должен гарантировать чистоту или возвращать изначальный root при ошибке,
		// но текущая реализация удаляет узел ошибки.
		// Чтобы избежать утечек в случае ошибки ДО трансформации корня,
		// можно было бы делать копию перед трансформацией или использовать умные указатели.
		// Для данного задания, предполагаем, что при ошибке трансформации выход корректен.
		return EXIT_FAILURE;
	}

	// Присваиваем новый корень переменной root для последующей очистки
    // (если корень сам был трансформирован)
    root = transformedRoot;


	// --- Вывод результата ---
	// Выводим указатель на корень полученного (трансформированного) дерева
	// Формат вывода указателя зависит от системы, обычно это шестнадцатеричный адрес
	cout << "Указатель на корень преобразованного дерева: " << root << endl;

	// --- Очистка памяти ---
	// Удаляем всё дерево, начиная с корня (деструктор Node рекурсивно удалит детей)
	delete root;
	root = nullptr; // Хорошая практика после delete

	return EXIT_SUCCESS;
}