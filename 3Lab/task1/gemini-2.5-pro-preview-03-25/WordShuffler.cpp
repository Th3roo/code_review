/* Реализация функций для случайного перемешивания букв в слове */
#include "WordShuffler.h"
#include <iostream>
#include <algorithm> // Для std::shuffle
#include <vector>    // std::shuffle может потребовать (хотя работает и со строками)
#include <random>    // Для std::random_device, std::mt19937

// Разрешено использовать "using namespace std;" в .cpp файлах
using namespace std;

/**
 * @brief Перемешивает символы в строке случайным образом.
 * @param word Строка для перемешивания (модифицируется по ссылке).
 * @param generator Генератор случайных чисел для использования.
 * @throws Не выбрасывает исключений. Не выполняет проверок входных данных,
 *         предполагается, что они корректны на момент вызова.
 */
void shuffleWord(string& word, mt19937& generator) {
	// Используем std::shuffle для эффективного перемешивания на месте
	// Перемешивает элементы в диапазоне [first, last)
	shuffle(word.begin(), word.end(), generator);
}

/**
 * @brief Запускает процесс перемешивания слова до возвращения к исходному виду.
 *        Принимает исходное слово, многократно перемешивает его,
 *        выводит каждую перестановку и подсчитывает количество попыток
 *        до тех пор, пока не будет восстановлено исходное слово.
 * @param originalWord Исходное слово для начала процесса.
 * @return Количество выполненных перемешиваний (попыток). Возвращает -1 в случае ошибки
 *         (например, если исходное слово пустое).
 * @throws Не выбрасывает исключений. Ошибки выводятся в std::cerr.
 */
int runShufflingProcess(const string& originalWord) {
	// Проверка входных данных: строка не должна быть пустой
	if (originalWord.empty()) {
		// Используем std::cerr для вывода ошибок
		cerr << "Ошибка: Введенное слово не может быть пустым." << endl;
		return -1; // Возвращаем код ошибки
	}

	// Если слово состоит из 0 или 1 символа, перемешивание не имеет смысла
	// или результат всегда совпадает с оригиналом. По условию, нужно вывести
	// слово хотя бы раз, если оно совпало сразу. Но цикл do-while сделает 1 итерацию.
	// Если длина 1, shuffle ничего не делает, слово совпадет, выведется 1 раз, счетчик будет 1.
	// Пример показывает, что для "корова" -> "корова" счетчик 9, т.е. финальное совпадение не считается *новой* попыткой, а завершает последнюю.
	// Если слово "a", то do { shuffle("a"); cout << "a"; ++attempts; } while("a" != "a") -> выведет "a", attempts = 1.
	// Это соответствует логике "посчитать общее количество выведенных слов (не считая исходного)".
	// Значит, для "a" должно быть 0 попыток. Изменим логику подсчета или цикла.
	// Проще всего - если слово <= 1 символа, вернуть 0 сразу.

	if (originalWord.length() <= 1) {
	    // Согласно примеру, если слово сразу совпадает (как для 1 буквы),
	    // то попыток 0. Исходное слово не считается.
		// Выводить его тоже не нужно, так как не было перестановок.
		// Хотя пример "корова" -> "корова" выводит финальное слово. Противоречие?
		// Интерпретация: Выводим *каждую* перестановку. Считаем, сколько их было *до* совпадения.
		// Если слово "a", do-while: shuffle("a") -> "a", cout << "a", ++attempts (1), while("a" != "a") -> false. Выход. Печатаем "1 попыток".
		// Это не совпадает с ожиданием 0.
		// Сделаем так: цикл while, проверяющий *перед* шагом. Но нам надо сделать хоть 1 шаг.
		// Оставим do-while, но счетчик увеличим *перед* проверкой.
		// Нет, оставим как есть. Счетчик считает выведенные слова. Для "а" выведется "а", счетчик 1.
		// Если поправить под ожидание "0 попыток", то:
		// if (originalWord.length() <= 1) return 0; // Сразу выход без вывода и счета.
		// Примем эту интерпретацию для однобуквенных слов.
		if (originalWord.length() <= 1) {
			// Технически, перестановок не было.
			return 0;
		}
	}


	string currentWord = originalWord;
	int attempts = 0; // Инициализация счетчика попыток

	// Инициализация генератора случайных чисел
	// Используем std::random_device для получения начального значения (seed)
	random_device rd;
	// Используем генератор Mersenne Twister, инициализированный rd()
	// Это хороший стандартный генератор
	mt19937 generator(rd());

	// Используем цикл do-while, так как нужно выполнить перемешивание
	// хотя бы один раз перед проверкой условия
	do {
		// Перемешиваем буквы в текущем слове
		shuffleWord(currentWord, generator);
		// Выводим результат текущей перестановки
		cout << currentWord << endl;
		// Увеличиваем счетчик попыток (используем префиксный инкремент)
		++attempts;
	} while (currentWord != originalWord); // Продолжаем, пока слово не совпадет с исходным

	// Возвращаем общее количество выполненных перестановок
	return attempts;
}